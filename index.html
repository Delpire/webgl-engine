<html>
	<head>
	
	<!-- Scrips -->
	<script id="shader-fs" type="x-shader/x-fragment">
		const lowp int MAX_NUM_OF_LIGHTS = 4;
		
		varying highp vec2 vTextureCoord;
		varying mediump vec3 vNormal;
		varying mediump vec3 vLightPosition[MAX_NUM_OF_LIGHTS];
		varying mediump vec3 vToCamera;
		
		varying mediump vec3 vLightColor[MAX_NUM_OF_LIGHTS];
        
        varying mediump vec2 fragTexCoord;
        varying mediump vec3 fragNormal;

		uniform sampler2D uSampler;
		uniform highp float uShineDamper;
		uniform highp float uReflectivity;
        uniform lowp int uNumberOfLights;
        uniform mediump vec3 ambientLightIntensity;
        uniform mediump vec3 uDirectionalLightIntensity;
        uniform mediump vec3 uDirectionalLightDirection;
        uniform bool directionalLightPresent;

		void main(void) {
			mediump vec4 texelColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
			
            mediump float brightness = 0.0;
            mediump float dampedFactor = 0.0;
            mediump float specularFactor = 0.0;
			mediump vec3 unitNormal = normalize(vNormal);
            mediump vec3 unitVectorToCamera = normalize(vToCamera);
            mediump vec3 unitLight;
            mediump vec3 diffuse;
            mediump vec3 lightDirection;
            mediump vec3 reflectedLightDirection;
            mediump vec3 finalSpecular;
            mediump vec3 lightIntensity = vec3(0.0, 0.0, 0.0);
            
            mediump vec3 ambientLightIntensity = vec3(0.2, 0.2, 0.2);
            
            if(uDirectionalLightIntensity != vec3(0.0, 0.0, 0.0)){
                lightIntensity = ambientLightIntensity +
                    uDirectionalLightIntensity * max(dot(vNormal, uDirectionalLightDirection), 0.0);
            }
            
            for(int i = 0; i < MAX_NUM_OF_LIGHTS; i++) {
                if(i > uNumberOfLights) {
                    break;
                }
                unitLight = normalize(vLightPosition[i]);
                brightness = max(dot(unitNormal, unitLight), 0.0);
                diffuse += brightness * vLightColor[i];
                diffuse += lightIntensity;
                
                lightDirection = -unitLight;
                reflectedLightDirection = reflect(lightDirection, unitNormal);
                specularFactor = dot(reflectedLightDirection, unitVectorToCamera);
                specularFactor = max(specularFactor, 0.0);
                dampedFactor = pow(specularFactor, uShineDamper);
                finalSpecular += dampedFactor * uReflectivity * vLightColor[i];     
            }
		
			gl_FragColor = vec4(diffuse, 1.0) * texelColor + vec4(finalSpecular, 1.0);
		}
	</script>

	<script id="shader-vs" type="x-shader/x-vertex">
		const lowp int MAX_NUM_OF_LIGHTS = 4;
	
		//Model Attributes
		attribute highp vec3 aVertexNormal;
		attribute highp vec3 aVertexPosition;
		attribute highp vec2 aTextureCoord;
		
		//Light Uniforms
		uniform mediump vec3 uLightPosition[MAX_NUM_OF_LIGHTS];
		uniform mediump vec3 uLightColor[MAX_NUM_OF_LIGHTS];
        uniform lowp int uNumberOfLights;
		
		//MVP Matrix Uniforms
		uniform highp mat4 uVMatrix;
		uniform highp mat4 uMMatrix;
		uniform highp mat4 uPMatrix;
		uniform highp mat4 invUMMatrix;
		
		varying highp vec2 vTextureCoord; 
		varying mediump vec3 vNormal;
		varying mediump vec3 vLightPosition[MAX_NUM_OF_LIGHTS];
		varying mediump vec3 vLightColor[MAX_NUM_OF_LIGHTS];
		varying mediump vec3 vToCamera;
        
        varying mediump vec3 fragNormal;
		
		void main(void) {
		
			vec4 worldPosition = uMMatrix * vec4(aVertexPosition, 1.0);
			gl_Position = uPMatrix * uVMatrix * worldPosition;
			vTextureCoord = aTextureCoord;
			
			vNormal = (uMMatrix * vec4(aVertexNormal, 0.0)).xyz;
            
            for(int i = 0; i < MAX_NUM_OF_LIGHTS; i++) {
                if(i > uNumberOfLights) {
                    break;
                }
                vLightPosition[i] = uLightPosition[i] - worldPosition.xyz;
                vLightColor[i] = uLightColor[i];
            }
			mat4 invUVMatrix = invUMMatrix;
			vToCamera = (invUVMatrix * vec4(0.0, 0.0, 0.0, 0.1)).xyz - worldPosition.xyz;
		}
	</script>
	<script src=".\toji-gl-matrix-14ad027\dist\gl-matrix-min.js"></script>
	<script src="inputEngine.js"></script>
	<script src="pointLightNode.js"></script>
    <script src="directionalLightNode.js"></script>
    <script src="cameraNode.js"></script>
    <script src="player.js"></script>
	<script src="modelData.js"></script>
	<script src="modelNode.js"></script>
	<script src="assetEngine.js"></script>
	<script src="sceneGraph.js"></script>
	<script src="renderEngine.js"></script>
	<script src="updateEngine.js"></script>
	<script src="game.js"></script>
	</head>

	<body>
	<canvas id="canvas" width="1024" height="576"></canvas>
	</body>



</html>